import * as Blockly from "blockly";

// Category: App
Blockly.Blocks["flipper_app"] = {
  init: function () {
  this.appendDummyInput().appendField("Kiisu App");
  this.appendStatementInput("SETUP").setCheck(null).appendField("setup (runs once)");
  this.appendStatementInput("DRAW").setCheck(null).appendField("draw (GUI callback)");
  this.appendStatementInput("INPUT").setCheck(null).appendField("input (key events)");
  this.appendStatementInput("LOOP").setCheck(null).appendField("loop (until exit)");
    this.setColour(210);
  this.setTooltip("Wraps your app: Setup runs once, Draw is called to render on the canvas, Input handles button events, Loop repeats until you exit (e.g., on Back)");
    this.setHelpUrl("");
  },
};

// App Manifest (.FAM) — simplified: only essentials (appid, name, apptype, optional icon)
// Rationale: previous block exposed many seldom‑used fields creating noise. Advanced
// users can hand‑edit generated .fam comment if needed.
Blockly.Blocks["flipper_manifest"] = {
  init: function () {
    this.appendDummyInput().appendField("Manifest (.fam)");
    this.appendDummyInput()
      .appendField("appid")
      .appendField(new Blockly.FieldTextInput("my_app"), "APPID");
    this.appendDummyInput()
      .appendField("name")
      .appendField(new Blockly.FieldTextInput("My App"), "NAME");
    this.appendDummyInput()
      .appendField("apptype")
      .appendField(
        new Blockly.FieldDropdown([
          ["EXTERNAL", "FlipperAppType.EXTERNAL"],
          ["APP", "FlipperAppType.APP"],
          ["PLUGIN", "FlipperAppType.PLUGIN"],
        ]),
        "APPTYPE"
      );
    this.appendDummyInput()
      .appendField("icon (optional)")
      .appendField(new Blockly.FieldTextInput(""), "ICON");
    this.appendDummyInput()
      .appendField("category")
      .appendField(new Blockly.FieldTextInput("General"), "CATEGORY");
    this.appendDummyInput()
      .appendField("author")
      .appendField(new Blockly.FieldTextInput("Unknown"), "AUTHOR");
    this.appendDummyInput()
      .appendField("version")
      .appendField(new Blockly.FieldTextInput("0.1.0"), "VERSION");
    this.appendDummyInput()
      .appendField("stack (bytes)")
      .appendField(new Blockly.FieldNumber(4096, 512, 32768, 256), "STACK");
    this.appendDummyInput()
      .appendField("description")
      .appendField(new Blockly.FieldTextInput("Generated by Kiisu Blocks"), "DESCRIPTION");
    // Loose, non-attachable block
    this.setPreviousStatement(false);
    this.setNextStatement(false);
    this.setInputsInline(false);
    this.setColour(210);
    this.setTooltip("Minimal App manifest. Advanced fields removed for clarity (entry_point auto, etc.).");
  },
};

// Potentiometer (ADC) — reads wiper position or millivolts
Blockly.Blocks["flipper_potentiometer_read"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("Potentiometer on pin")
      .appendField(
        new Blockly.FieldDropdown([
          ["PA7 (Pin 2)", "PA7"],
          ["PA6 (Pin 3)", "PA6"],
          ["PA4 (Pin 4)", "PA4"],
          ["PC3 (Pin 7)", "PC3"],
          ["PC1 (Pin 15)", "PC1"],
          ["PC0 (Pin 16)", "PC0"],
        ]),
        "PIN"
      );
    this.appendDummyInput()
      .appendField("resistance")
      .appendField(new Blockly.FieldNumber(10, 0.1, 10000, 0.1), "R_VALUE")
      .appendField(
        new Blockly.FieldDropdown([
          ["Ω", "OHM"],
          ["kΩ", "KOHM"],
          ["MΩ", "MOHM"],
        ]),
        "R_UNIT"
      );
    this.appendDummyInput()
      .appendField("return")
      .appendField(
        new Blockly.FieldDropdown([
          ["Percent (0–100)", "PERCENT"],
          ["Millivolts (approx)", "MV"],
          ["Raw (0–4095)", "RAW"],
        ]),
        "MODE"
      );
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(45);
    this.setTooltip(
      "Reads potentiometer wiper via ADC. Wire between 3.3V and GND; wiper to the selected analog pin. High resistance (>10kΩ) may need slower sampling."
    );
  },
};

// Category: GUI/ViewPort
Blockly.Blocks["flipper_viewport_setup"] = {
  init: function () {
    this.appendDummyInput().appendField("setup viewport layer");
    this.appendDummyInput()
      .appendField("layer")
      .appendField(
        new Blockly.FieldDropdown([
          ["Fullscreen", "GuiLayerFullscreen"],
          ["Window", "GuiLayerWindow"],
        ]),
        "LAYER"
      );
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(160);
  this.setTooltip("Allocates a ViewPort, wires draw/input callbacks, enables it, and adds it to the GUI on the chosen layer");
  },
};

// Category: Canvas
Blockly.Blocks["flipper_canvas_clear"] = {
  init: function () {
    this.appendDummyInput().appendField("canvas clear");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
  this.setTooltip("Clear the canvas at the start of each draw");
  },
};

Blockly.Blocks["flipper_canvas_set_font"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("canvas set font")
      .appendField(
        new Blockly.FieldDropdown([
          ["Primary", "FontPrimary"],
          ["Secondary", "FontSecondary"],
          ["BigNumbers", "FontBigNumbers"],
        ]),
        "FONT"
      );
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
  this.setTooltip("Choose built-in font for following text draws");
  },
};

Blockly.Blocks["flipper_canvas_set_color"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("canvas set color")
      .appendField(
        new Blockly.FieldDropdown([
          ["Black", "ColorBlack"],
          ["White", "ColorWhite"],
          ["XOR", "ColorXOR"],
        ]),
        "COLOR"
      );
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
  this.setTooltip("Set canvas color: Black/White/XOR");
  },
};

Blockly.Blocks["flipper_canvas_draw_text"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("draw text x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
    this.appendValueInput("TEXT").setCheck("String").appendField("text");
  this.appendDummyInput().appendField("invert").appendField(new Blockly.FieldCheckbox("FALSE"), "XOR");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
  this.setTooltip("Draw UTF-8 text at (x, y)");
  },
};

// Aligned text
Blockly.Blocks["flipper_canvas_draw_text_aligned"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("draw text aligned x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
    this.appendDummyInput()
      .appendField("h-align")
      .appendField(
        new Blockly.FieldDropdown([
          ["Left", "AlignLeft"],
          ["Center", "AlignCenter"],
          ["Right", "AlignRight"],
        ]),
        "HALIGN"
      )
      .appendField("v-align")
      .appendField(
        new Blockly.FieldDropdown([
          ["Top", "AlignTop"],
          ["Center", "AlignCenter"],
          ["Bottom", "AlignBottom"],
        ]),
        "VALIGN"
      );
    this.appendValueInput("TEXT").setCheck("String").appendField("text");
    this.appendDummyInput().appendField("invert").appendField(new Blockly.FieldCheckbox("FALSE"), "XOR");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
    this.setTooltip("Draw aligned text at (x, y) using canvas_draw_str_aligned");
  },
};

// Canvas primitives
Blockly.Blocks["flipper_canvas_draw_box"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("draw box x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
    this.appendValueInput("W").setCheck("Number").appendField("w");
    this.appendValueInput("H").setCheck("Number").appendField("h");
  this.appendDummyInput().appendField("invert").appendField(new Blockly.FieldCheckbox("FALSE"), "XOR");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
    this.setTooltip("canvas_draw_box(canvas, x, y, w, h)");
  },
};

Blockly.Blocks["flipper_canvas_draw_frame"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("draw frame x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
    this.appendValueInput("W").setCheck("Number").appendField("w");
    this.appendValueInput("H").setCheck("Number").appendField("h");
  this.appendDummyInput().appendField("invert").appendField(new Blockly.FieldCheckbox("FALSE"), "XOR");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
    this.setTooltip("canvas_draw_frame(canvas, x, y, w, h)");
  },
};

// Rounded box/frame
Blockly.Blocks["flipper_canvas_draw_rbox"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("draw rounded box x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
    this.appendValueInput("W").setCheck("Number").appendField("w");
    this.appendValueInput("H").setCheck("Number").appendField("h");
    this.appendValueInput("R").setCheck("Number").appendField("radius");
    this.appendDummyInput().appendField("invert").appendField(new Blockly.FieldCheckbox("FALSE"), "XOR");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
    this.setTooltip("canvas_draw_rbox(canvas, x, y, w, h, r)");
  },
};

Blockly.Blocks["flipper_canvas_draw_rframe"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("draw rounded frame x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
    this.appendValueInput("W").setCheck("Number").appendField("w");
    this.appendValueInput("H").setCheck("Number").appendField("h");
    this.appendValueInput("R").setCheck("Number").appendField("radius");
    this.appendDummyInput().appendField("invert").appendField(new Blockly.FieldCheckbox("FALSE"), "XOR");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
    this.setTooltip("canvas_draw_rframe(canvas, x, y, w, h, r)");
  },
};

Blockly.Blocks["flipper_canvas_draw_line"] = {
  init: function () {
    this.appendValueInput("X1").setCheck("Number").appendField("draw line x1");
    this.appendValueInput("Y1").setCheck("Number").appendField("y1");
    this.appendValueInput("X2").setCheck("Number").appendField("x2");
    this.appendValueInput("Y2").setCheck("Number").appendField("y2");
  this.appendDummyInput().appendField("invert").appendField(new Blockly.FieldCheckbox("FALSE"), "XOR");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
    this.setTooltip("canvas_draw_line(canvas, x1, y1, x2, y2)");
  },
};

Blockly.Blocks["flipper_canvas_draw_circle"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("draw circle x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
    this.appendValueInput("R").setCheck("Number").appendField("r");
  this.appendDummyInput().appendField("invert").appendField(new Blockly.FieldCheckbox("FALSE"), "XOR");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
    this.setTooltip("canvas_draw_circle(canvas, x, y, r)");
  },
};

Blockly.Blocks["flipper_canvas_draw_disc"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("draw disc x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
    this.appendValueInput("R").setCheck("Number").appendField("r");
  this.appendDummyInput().appendField("invert").appendField(new Blockly.FieldCheckbox("FALSE"), "XOR");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
    this.setTooltip("canvas_draw_disc(canvas, x, y, r)");
  },
};

Blockly.Blocks["flipper_canvas_draw_dot"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("draw dot x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
  this.appendDummyInput().appendField("XOR").appendField(new Blockly.FieldCheckbox("FALSE"), "XOR");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(20);
    this.setTooltip("canvas_draw_dot(canvas, x, y)");
  },
};

// Widget advanced text elements
Blockly.Blocks["flipper_widget_text_box"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("text box x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
    this.appendValueInput("W").setCheck("Number").appendField("w");
    this.appendValueInput("H").setCheck("Number").appendField("h");
    this.appendDummyInput()
      .appendField("h-align")
      .appendField(
        new Blockly.FieldDropdown([
          ["Left", "AlignLeft"],
          ["Center", "AlignCenter"],
          ["Right", "AlignRight"],
        ]),
        "HALIGN"
      )
      .appendField("v-align")
      .appendField(
        new Blockly.FieldDropdown([
          ["Top", "AlignTop"],
          ["Center", "AlignCenter"],
          ["Bottom", "AlignBottom"],
        ]),
        "VALIGN"
      );
    this.appendValueInput("TEXT").setCheck("String").appendField("text");
    this.appendDummyInput().appendField("truncate ...").appendField(new Blockly.FieldCheckbox("TRUE"), "STRIP");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(160);
    this.setTooltip("widget_add_text_box_element(widget, x, y, w, h, hAlign, vAlign, text, strip_to_dots)");
  },
};

Blockly.Blocks["flipper_widget_text_scroll"] = {
  init: function () {
    this.appendValueInput("X").setCheck("Number").appendField("scroll text x");
    this.appendValueInput("Y").setCheck("Number").appendField("y");
    this.appendValueInput("W").setCheck("Number").appendField("w");
    this.appendValueInput("H").setCheck("Number").appendField("h");
    this.appendValueInput("TEXT").setCheck("String").appendField("text");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(160);
    this.setTooltip("widget_add_text_scroll_element(widget, x, y, w, h, text)");
  },
};

// Widget button icon
Blockly.Blocks["flipper_widget_button"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("button icon")
      .appendField(
        new Blockly.FieldDropdown([
          ["Left", "GuiButtonTypeLeft"],
          ["Center", "GuiButtonTypeCenter"],
          ["Right", "GuiButtonTypeRight"],
        ]),
        "BTN"
      );
    this.appendValueInput("LABEL").setCheck("String").appendField("label");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(210);
    this.setTooltip("Adds a button icon at the bottom of the screen. Use input blocks to handle button presses.");
  },
};

Blockly.Blocks["flipper_canvas_width"] = {
  init: function () {
    this.appendDummyInput().appendField("canvas width");
    this.setOutput(true, "Number");
    this.setColour(20);
    this.setTooltip("canvas_width(canvas)");
  },
};

Blockly.Blocks["flipper_canvas_height"] = {
  init: function () {
    this.appendDummyInput().appendField("canvas height");
    this.setOutput(true, "Number");
    this.setColour(20);
    this.setTooltip("canvas_height(canvas)");
  },
};

// Category: Input
Blockly.Blocks["flipper_input_exit_on_back_short"] = {
  init: function () {
    this.appendDummyInput().appendField("exit on Back Short");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(290);
  this.setTooltip("When the Back button is tapped (short press), stop the main loop and exit the app");
  },
};

// Category: Notifications
Blockly.Blocks["flipper_notify_sequence"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("notify")
      .appendField(
        new Blockly.FieldDropdown([
          ["success", "sequence_success"],
          ["error", "sequence_error"],
          ["backlight on", "sequence_display_backlight_on"],
          ["backlight off", "sequence_display_backlight_off"],
          ["single vibro", "sequence_single_vibro"],
        ]),
        "SEQ"
      );
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(330);
  this.setTooltip("Play a notification preset (played once at start)");
  },
};

// Category: Timing
Blockly.Blocks["flipper_sleep_ms"] = {
  init: function () {
    this.appendValueInput("MS").setCheck("Number").appendField("sleep ms");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(60);
    this.setTooltip("Delay using furi_delay_ms(ms). Avoid inside draw/input callbacks.");
  },
};

// Category: Logging
Blockly.Blocks["flipper_log"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("log")
      .appendField(
        new Blockly.FieldDropdown([
          ["INFO", "I"],
          ["WARN", "W"],
          ["ERROR", "E"],
          ["DEBUG", "D"],
          ["TRACE", "T"],
        ]),
        "LEVEL"
      );
    this.appendValueInput("TAG").setCheck("String").appendField("tag");
    this.appendValueInput("MSG").setCheck("String").appendField("msg");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(260);
    this.setTooltip("FURI_LOG_[E/W/I/D/T](tag, msg)");
  },
};

// Category: Input predicates
Blockly.Blocks["flipper_input_if_key_type"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("if input")
      .appendField(
        new Blockly.FieldDropdown([
          ["Short", "InputTypeShort"],
          ["Press", "InputTypePress"],
          ["Release", "InputTypeRelease"],
          ["Long", "InputTypeLong"],
          ["Repeat", "InputTypeRepeat"],
        ]),
        "TYPE"
      )
      .appendField("and key")
      .appendField(
        new Blockly.FieldDropdown([
          ["Up", "InputKeyUp"],
          ["Down", "InputKeyDown"],
          ["Left", "InputKeyLeft"],
          ["Right", "InputKeyRight"],
          ["OK", "InputKeyOk"],
          ["Back", "InputKeyBack"],
        ]),
        "KEY"
      );
    this.appendStatementInput("DO").setCheck(null).appendField("do");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(290);
    this.setTooltip("Inside input callback: runs body when event matches type and key");
  },
};

// Category: Screen helpers
Blockly.Blocks["flipper_request_redraw"] = {
  init: function () {
    this.appendDummyInput().appendField("request redraw");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(160);
    this.setTooltip("Call view_port_update(view_port) to trigger draw callback again");
  },
};

// Category: Utilities
Blockly.Blocks["flipper_string_to_number"] = {
  init: function () {
    this.appendValueInput("STRING").setCheck("String").appendField("string to number");
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Convert a string to a number using atoi()");
  },
};

Blockly.Blocks["flipper_number_to_string"] = {
  init: function () {
    this.appendValueInput("NUMBER").setCheck("Number").appendField("number to string");
    this.setOutput(true, "String");
    this.setColour(230);
    this.setTooltip("Convert a number to a string using snprintf()");
  },
};

Blockly.Blocks["flipper_string_length"] = {
  init: function () {
    this.appendValueInput("STRING").setCheck("String").appendField("length of");
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Get the length of a string using strlen()");
  },
};

Blockly.Blocks["flipper_random_number"] = {
  init: function () {
    this.appendValueInput("MIN").setCheck("Number").appendField("random from");
    this.appendValueInput("MAX").setCheck("Number").appendField("to");
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Generate a random number between min and max (inclusive)");
  },
};

// Category: Storage
Blockly.Blocks["flipper_storage_read"] = {
  init: function () {
    this.appendValueInput("PATH").setCheck("String").appendField("read file");
    this.setOutput(true, "String");
    this.setColour(120);
    this.setTooltip("Read text content from a file on storage");
  },
};

Blockly.Blocks["flipper_storage_write"] = {
  init: function () {
    this.appendValueInput("PATH").setCheck("String").appendField("write to file");
    this.appendValueInput("DATA").setCheck("String").appendField("data");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(120);
    this.setTooltip("Write text data to a file on storage");
  },
};

Blockly.Blocks["flipper_storage_exists"] = {
  init: function () {
    this.appendValueInput("PATH").setCheck("String").appendField("file exists");
    this.setOutput(true, "Boolean");
    this.setColour(120);
    this.setTooltip("Check if a file exists on storage");
  },
};

Blockly.Blocks["flipper_storage_create"] = {
  init: function () {
    this.appendValueInput("PATH").setCheck("String").appendField("create new file");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(120);
    this.setTooltip("Create a new empty file on storage");
  },
};

Blockly.Blocks["flipper_storage_delete"] = {
  init: function () {
    this.appendValueInput("PATH").setCheck("String").appendField("delete file");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(120);
    this.setTooltip("Delete a file from storage");
  },
};

// GPIO blocks with dropdowns
Blockly.Blocks["flipper_gpio_init"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("setup pin")
      .appendField(new Blockly.FieldDropdown([
        ["PA7 (Pin 2)", "PA7"],
        ["PA6 (Pin 3)", "PA6"], 
        ["PA4 (Pin 4)", "PA4"],
        ["PB3 (Pin 5)", "PB3"],
        ["PB2 (Pin 6)", "PB2"],
        ["PC3 (Pin 7)", "PC3"],
        ["PC1 (Pin 15)", "PC1"],
        ["PC0 (Pin 16)", "PC0"]
      ]), "PIN")
      .appendField("as")
      .appendField(new Blockly.FieldDropdown([
        ["Input", "INPUT"],
        ["Output", "OUTPUT"],
        ["Analog", "ANALOG"]
      ]), "MODE")
      .appendField("pull")
      .appendField(new Blockly.FieldDropdown([
        ["None", "NONE"],
        ["Up", "UP"],
        ["Down", "DOWN"]
      ]), "PULL");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
    this.setTooltip("Initialize a GPIO pin with specified mode and pull resistor");
  },
};

Blockly.Blocks["flipper_gpio_write"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("write pin")
      .appendField(new Blockly.FieldDropdown([
        ["PA7 (Pin 2)", "PA7"],
        ["PA6 (Pin 3)", "PA6"], 
        ["PA4 (Pin 4)", "PA4"],
        ["PB3 (Pin 5)", "PB3"],
        ["PB2 (Pin 6)", "PB2"],
        ["PC3 (Pin 7)", "PC3"],
        ["PC1 (Pin 15)", "PC1"],
        ["PC0 (Pin 16)", "PC0"]
      ]), "PIN")
      .appendField("to")
      .appendField(new Blockly.FieldDropdown([
        ["HIGH", "HIGH"],
        ["LOW", "LOW"]
      ]), "STATE");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
    this.setTooltip("Write a digital value to a GPIO pin");
  },
};

Blockly.Blocks["flipper_gpio_read"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("read digital pin")
      .appendField(new Blockly.FieldDropdown([
        ["PA7 (Pin 2)", "PA7"],
        ["PA6 (Pin 3)", "PA6"], 
        ["PA4 (Pin 4)", "PA4"],
        ["PB3 (Pin 5)", "PB3"],
        ["PB2 (Pin 6)", "PB2"],
        ["PC3 (Pin 7)", "PC3"],
        ["PC1 (Pin 15)", "PC1"],
        ["PC0 (Pin 16)", "PC0"]
      ]), "PIN");
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Digital read: returns 1 or 0 from the selected pin");
  },
};

// GPIO: Analog read (ADC)
Blockly.Blocks["flipper_gpio_analog_read"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("read analog pin")
      .appendField(
        new Blockly.FieldDropdown([
          ["PA7 (Pin 2)", "PA7"],
          ["PA6 (Pin 3)", "PA6"],
          ["PA4 (Pin 4)", "PA4"],
          ["PC3 (Pin 7)", "PC3"],
          ["PC1 (Pin 15)", "PC1"],
          ["PC0 (Pin 16)", "PC0"],
        ]),
        "PIN"
      )
      .appendField("as")
      .appendField(
        new Blockly.FieldDropdown([
          ["raw (0–4095)", "RAW"],
          ["mV (0–2500)", "MV"],
        ]),
        "MODE"
      );
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Analog read via ADC on supported pins; returns raw 12-bit or millivolts (2.5V ref)");
  },
};

// GPIO: PWM read (last set via blocks)
Blockly.Blocks["flipper_pwm_read"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("read PWM on pin")
      .appendField(
        new Blockly.FieldDropdown([
          ["PA7 (Pin 2)", "PA7"],
          ["PA4 (Pin 4)", "PA4"],
        ]),
        "PIN"
      )
      .appendField("get")
      .appendField(
        new Blockly.FieldDropdown([
          ["duty %", "DUTY"],
          ["frequency Hz", "FREQ"],
        ]),
        "WHAT"
      );
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Returns the last PWM duty (%) or frequency (Hz) set on the pin using PWM blocks");
  },
};

// GPIO: PWM controls (only supported pins)
Blockly.Blocks["flipper_pwm_start"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("PWM start on pin")
      .appendField(
        new Blockly.FieldDropdown([
          ["PA7 (Pin 2)", "PA7"],
          ["PA4 (Pin 4)", "PA4"],
        ]),
        "PIN"
      );
    this.appendValueInput("FREQ").setCheck("Number").appendField("freq Hz");
    this.appendValueInput("DUTY").setCheck("Number").appendField("duty %");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
    this.setTooltip("Start PWM on a supported pin (PA7 via TIM1, PA4 via LPTIM2) with the given frequency and duty cycle (0–100%).");
  },
};

Blockly.Blocks["flipper_pwm_set"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("PWM set on pin")
      .appendField(
        new Blockly.FieldDropdown([
          ["PA7 (Pin 2)", "PA7"],
          ["PA4 (Pin 4)", "PA4"],
        ]),
        "PIN"
      );
    this.appendValueInput("FREQ").setCheck("Number").appendField("freq Hz");
    this.appendValueInput("DUTY").setCheck("Number").appendField("duty %");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
    this.setTooltip("Update PWM frequency and duty cycle on a supported pin; starts PWM if not already running.");
  },
};

Blockly.Blocks["flipper_pwm_stop"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("PWM stop on pin")
      .appendField(
        new Blockly.FieldDropdown([
          ["PA7 (Pin 2)", "PA7"],
          ["PA4 (Pin 4)", "PA4"],
        ]),
        "PIN"
      );
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
    this.setTooltip("Stop PWM on the selected supported pin (PA7/PA4).");
  },
};

// Timer block for periodic execution
Blockly.Blocks["flipper_timer_periodic"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("every")
      .appendField(new Blockly.FieldNumber(500, 1, 10000), "INTERVAL")
      .appendField("ms do");
    this.appendStatementInput("DO")
      .setCheck(null);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(120);
    this.setTooltip("Execute blocks repeatedly at the specified interval");
  },
};

// --- Additional Logic / Bitwise Blocks (if base toolbox lacks them) ---
// We rely on core Blockly for logic_operation (AND/OR) & logic_negate. Provide
// explicit bitwise operators for advanced users targeting C code.
// Bitwise AND
Blockly.Blocks["flipper_bitwise_and"] = {
  init: function () {
    this.appendValueInput("A").setCheck("Number").appendField("bitwise AND");
    this.appendValueInput("B").setCheck("Number").appendField("&");
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Returns A & B (bitwise AND)");
  }
};

// Bitwise OR
Blockly.Blocks["flipper_bitwise_or"] = {
  init: function () {
    this.appendValueInput("A").setCheck("Number").appendField("bitwise OR");
    this.appendValueInput("B").setCheck("Number").appendField("|");
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Returns A | B (bitwise OR)");
  }
};

// Bitwise XOR
Blockly.Blocks["flipper_bitwise_xor"] = {
  init: function () {
    this.appendValueInput("A").setCheck("Number").appendField("bitwise XOR");
    this.appendValueInput("B").setCheck("Number").appendField("^");
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Returns A ^ B (bitwise XOR)");
  }
};

// Bitwise NOT
Blockly.Blocks["flipper_bitwise_not"] = {
  init: function () {
    this.appendValueInput("A").setCheck("Number").appendField("bitwise NOT ~");
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Returns ~A (bitwise NOT)");
  }
};

// Category: Outputs
Blockly.Blocks["flipper_servo_180"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("set servo on pin")
      .appendField(new Blockly.FieldDropdown([
  ["PA7 (Pin 2)", "PA7"],
  ["PA4 (Pin 4)", "PA4"]
      ]), "PIN");
    this.appendValueInput("ANGLE")
      .setCheck("Number")
      .appendField("to angle");
    this.appendDummyInput()
      .appendField("°");
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(285);
    this.setTooltip(
      "Set a 180° servo to angle (0–180°). Supported PWM pins: PA7 (TIM1), PA4 (LPTIM2). Other pins won't drive a servo."
    );
    // Live warning if an unsupported pin is chosen
    this.setOnChange(function () {
      // Some onChange events fire before fields exist
      const block = this as Blockly.Block;
      const pin = (block.getFieldValue && (block.getFieldValue as (name: string) => string)("PIN")) as string | undefined;
      if (!pin) return;
      const supported = pin === "PA7" || pin === "PA4";
      if (block.setWarningText) {
        block.setWarningText(supported ? null : "Selected pin does not support PWM for servo control. Use PA7 or PA4.");
      }
    });
  },
};

// Outputs: Servo unlock (stop PWM)
Blockly.Blocks["flipper_servo_unlock"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("unlock servo on pin")
      .appendField(
        new Blockly.FieldDropdown([
          ["PA7 (Pin 2)", "PA7"],
          ["PA4 (Pin 4)", "PA4"],
        ]),
        "PIN"
      );
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(285);
    this.setTooltip("Stop PWM on the selected servo pin to release holding torque (PA7/PA4 only).");
  },
};

// Category: Inputs (Sensors)
// Ultrasonic Distance Sensor (HC-SR04) — returns distance in centimeters
Blockly.Blocks["flipper_ultrasonic_distance_cm"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("Ultrasonic distance (cm)")
      .appendField("Trig")
      .appendField(
        new Blockly.FieldDropdown([
          ["TX (Pin 13)", "USART_TX"],
          ["PA7 (Pin 2)", "PA7"],
          ["PA6 (Pin 3)", "PA6"],
          ["PA4 (Pin 4)", "PA4"],
          ["PB3 (Pin 5)", "PB3"],
          ["PB2 (Pin 6)", "PB2"],
          ["PC3 (Pin 7)", "PC3"],
          ["PC1 (Pin 15)", "PC1"],
          ["PC0 (Pin 16)", "PC0"],
        ]),
        "TRIG_PIN"
      )
      .appendField("Echo")
      .appendField(
        new Blockly.FieldDropdown([
          ["RX (Pin 14)", "USART_RX"],
          ["PA7 (Pin 2)", "PA7"],
          ["PA6 (Pin 3)", "PA6"],
          ["PA4 (Pin 4)", "PA4"],
          ["PB3 (Pin 5)", "PB3"],
          ["PB2 (Pin 6)", "PB2"],
          ["PC3 (Pin 7)", "PC3"],
          ["PC1 (Pin 15)", "PC1"],
          ["PC0 (Pin 16)", "PC0"],
        ]),
        "ECHO_PIN"
      );
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(45);
    this.setTooltip(
      "Measures distance using HC-SR04 in cm. Requires 5V on GPIO."
    );
  },
};

// PIR Motion Sensor (HC-SR501): returns true when motion detected (Echo 3.3V high)
Blockly.Blocks["flipper_pir_motion"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("PIR motion on pin")
      .appendField(
        new Blockly.FieldDropdown([
          ["PA7 (Pin 2)", "PA7"],
          ["PA6 (Pin 3)", "PA6"],
          ["PA4 (Pin 4)", "PA4"],
          ["PB3 (Pin 5)", "PB3"],
          ["PB2 (Pin 6)", "PB2"],
          ["PC3 (Pin 7)", "PC3"],
          ["PC1 (Pin 15)", "PC1"],
          ["PC0 (Pin 16)", "PC0"],
        ]),
        "PIN"
      );
    this.setOutput(true, "Boolean");
    this.setColour(45);
    this.setTooltip(
      "HC-SR501 PIR Motion: outputs true when motion detected. Module requires 5–20V power; signal is 3.3V TTL."
    );
  },
};

// DHT11 Temperature (°C) — single-wire on supported GPIO pins
Blockly.Blocks["flipper_dht11_temp_c"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("DHT11 temperature (°C) on pin")
      .appendField(
        new Blockly.FieldDropdown([
          ["PA7 (Pin 2)", "PA7"],
          ["PA6 (Pin 3)", "PA6"],
          ["PA4 (Pin 4)", "PA4"],
          ["PB3 (Pin 5)", "PB3"],
          ["PB2 (Pin 6)", "PB2"],
          ["PC3 (Pin 7)", "PC3"],
          ["PC1 (Pin 15)", "PC1"],
          ["PC0 (Pin 16)", "PC0"],
        ]),
        "PIN"
      );
    this.setOutput(true, "Number");
    this.setColour(45);
    this.setTooltip(
      "Reads DHT11 temperature in °C. Single-wire with 5.1k pull-up; read no faster than every 2s (sensor updates ~1Hz)."
    );
  },
};

// DHT11 Humidity (%) — single-wire on supported GPIO pins
Blockly.Blocks["flipper_dht11_humidity_percent"] = {
  init: function () {
    this.appendDummyInput()
      .appendField("DHT11 humidity (%) on pin")
      .appendField(
        new Blockly.FieldDropdown([
          ["PA7 (Pin 2)", "PA7"],
          ["PA6 (Pin 3)", "PA6"],
          ["PA4 (Pin 4)", "PA4"],
          ["PB3 (Pin 5)", "PB3"],
          ["PB2 (Pin 6)", "PB2"],
          ["PC3 (Pin 7)", "PC3"],
          ["PC1 (Pin 15)", "PC1"],
          ["PC0 (Pin 16)", "PC0"],
        ]),
        "PIN"
      );
    this.setOutput(true, "Number");
    this.setColour(45);
    this.setTooltip(
      "Reads DHT11 relative humidity in %. Single-wire with 5.1k pull-up; read no faster than every 2s."
    );
  },
};

// ================= I2C Blocks =================
// Bus dropdown options: External (I2C3 on GPIO edge connector) and Power (internal sensors/power rail)
// Simple, high-level register read/write helpers wrapping HAL acquire/read/release

// Hex number literal (for addresses / registers)
Blockly.Blocks["flipper_hex_number"] = {
  init: function () {
    const validate = (txt: string) => {
      if(!txt) return "0x0";
      txt = txt.trim();
      if(!txt.startsWith("0x") && !txt.startsWith("0X")) {
        if(/^[0-9A-Fa-f]+$/.test(txt)) txt = "0x" + txt; else txt = "0x0";
      }
      // Keep only hex digits after 0x, limit to 8 chars (32-bit)
      const body = txt.slice(2).replace(/[^0-9A-Fa-f]/g, '').slice(0,8) || '0';
      return "0x" + body.toUpperCase();
    };
    this.appendDummyInput()
      .appendField("hex")
      .appendField(new Blockly.FieldTextInput("0x00", validate), "HEX");
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("Hex literal (0x..). Accepts up to 32-bit. Useful for I2C addresses and registers.");
  }
};

Blockly.Blocks["flipper_i2c_read_reg8"] = {
  init: function () {
    this.appendDummyInput()
          .appendField("I2C read 8-bit reg bus")
  .appendField(new Blockly.FieldDropdown([["GPIO (PA7 SDA/PA6 SCL)","EXT"],["Internal","PWR"]]), "BUS");
    this.appendValueInput("ADDR").setCheck("Number").appendField("addr (7b)");
    this.appendValueInput("REG").setCheck("Number").appendField("reg");
    this.appendValueInput("TIMEOUT").setCheck("Number").appendField("timeout ms");
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(260);
        this.setTooltip("Reads 8-bit register from an I2C device (7-bit address). External bus uses PA7 SDA, PA6 SCL.");
    const mkHexShadow = (hex:string)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','flipper_hex_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','HEX');f.textContent=hex; s.appendChild(f); return s;};
    const mkNumShadow = (val:number)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','math_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','NUM');f.textContent=String(val);s.appendChild(f);return s;};
    this.getInput('ADDR')?.connection.setShadowDom(mkHexShadow('0x3C'));
    this.getInput('REG')?.connection.setShadowDom(mkHexShadow('0x00'));
    this.getInput('TIMEOUT')?.connection.setShadowDom(mkNumShadow(50));
  }
};

Blockly.Blocks["flipper_i2c_write_reg8"] = {
  init: function () {
    this.appendDummyInput()
          .appendField("I2C write8 bus")
  .appendField(new Blockly.FieldDropdown([["GPIO (PA7/PA6)","EXT"],["Internal","PWR"]]), "BUS");
    this.appendValueInput("ADDR").setCheck("Number").appendField("addr (7b)");
    this.appendValueInput("REG").setCheck("Number").appendField("reg");
    this.appendValueInput("VALUE").setCheck("Number").appendField("value");
    this.appendValueInput("TIMEOUT").setCheck("Number").appendField("timeout ms");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(260);
        this.setTooltip("Writes 8-bit value to an I2C device register. External bus uses PA7 SDA, PA6 SCL.");
    const mkHexShadow = (hex:string)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','flipper_hex_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','HEX');f.textContent=hex; s.appendChild(f); return s;};
    const mkNumShadow = (val:number)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','math_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','NUM');f.textContent=String(val);s.appendChild(f);return s;};
    this.getInput('ADDR')?.connection.setShadowDom(mkHexShadow('0x3C'));
    this.getInput('REG')?.connection.setShadowDom(mkHexShadow('0x00'));
    this.getInput('VALUE')?.connection.setShadowDom(mkHexShadow('0x01'));
    this.getInput('TIMEOUT')?.connection.setShadowDom(mkNumShadow(50));
  }
};

Blockly.Blocks["flipper_i2c_read_reg16"] = {
  init: function () {
    this.appendDummyInput()
          .appendField("I2C read 16-bit reg bus")
  .appendField(new Blockly.FieldDropdown([["GPIO (PA7/PA6)","EXT"],["Internal","PWR"]]), "BUS");
    this.appendValueInput("ADDR").setCheck("Number").appendField("addr (7b)");
    this.appendValueInput("REG").setCheck("Number").appendField("reg");
    this.appendValueInput("TIMEOUT").setCheck("Number").appendField("timeout ms");
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(260);
        this.setTooltip("Reads 16-bit register from an I2C device (common for sensor words). External bus uses PA7 SDA, PA6 SCL.");
    const mkHexShadow = (hex:string)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','flipper_hex_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','HEX');f.textContent=hex; s.appendChild(f); return s;};
    const mkNumShadow = (val:number)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','math_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','NUM');f.textContent=String(val);s.appendChild(f);return s;};
    this.getInput('ADDR')?.connection.setShadowDom(mkHexShadow('0x3C'));
    this.getInput('REG')?.connection.setShadowDom(mkHexShadow('0x00'));
    this.getInput('TIMEOUT')?.connection.setShadowDom(mkNumShadow(50));
  }
};

Blockly.Blocks["flipper_i2c_write_reg16"] = {
  init: function () {
    this.appendDummyInput()
  .appendField("I2C write16 bus")
  .appendField(new Blockly.FieldDropdown([["GPIO (PA7/PA6)","EXT"],["Internal","PWR"]]), "BUS");
    this.appendValueInput("ADDR").setCheck("Number").appendField("addr (7b)");
    this.appendValueInput("REG").setCheck("Number").appendField("reg");
    this.appendValueInput("VALUE").setCheck("Number").appendField("value");
    this.appendValueInput("TIMEOUT").setCheck("Number").appendField("timeout ms");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(260);
  this.setTooltip("Writes 16-bit value to an I2C device register. External bus uses PA7 SDA, PA6 SCL.");
    const mkHexShadow = (hex:string)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','flipper_hex_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','HEX');f.textContent=hex; s.appendChild(f); return s;};
    const mkNumShadow = (val:number)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','math_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','NUM');f.textContent=String(val);s.appendChild(f);return s;};
    this.getInput('ADDR')?.connection.setShadowDom(mkHexShadow('0x3C'));
    this.getInput('REG')?.connection.setShadowDom(mkHexShadow('0x00'));
    this.getInput('VALUE')?.connection.setShadowDom(mkHexShadow('0x1234'));
    this.getInput('TIMEOUT')?.connection.setShadowDom(mkNumShadow(50));
  }
};

Blockly.Blocks["flipper_i2c_device_ready"] = {
  init: function () {
    this.appendDummyInput()
  .appendField("I2C device ready bus")
  .appendField(new Blockly.FieldDropdown([["GPIO (PA7 SDA/PA6 SCL)","EXT"],["Internal","PWR"]]), "BUS");
    this.appendValueInput("ADDR").setCheck("Number").appendField("addr (7b)");
    this.appendValueInput("TIMEOUT").setCheck("Number").appendField("timeout ms");
    this.setInputsInline(true);
    this.setOutput(true, "Boolean");
    this.setColour(260);
  this.setTooltip("Tests if a device ACKs on the selected bus. External bus uses PA7 SDA, PA6 SCL.");
    const mkHexShadow = (hex:string)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','flipper_hex_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','HEX');f.textContent=hex; s.appendChild(f); return s;};
    const mkNumShadow = (val:number)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','math_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','NUM');f.textContent=String(val);s.appendChild(f);return s;};
    this.getInput('ADDR')?.connection.setShadowDom(mkHexShadow('0x3C'));
    this.getInput('TIMEOUT')?.connection.setShadowDom(mkNumShadow(20));
  }
};

// Byte stream literal (list of hex bytes) -> used for I2C write bytes or other future protocols
Blockly.Blocks["flipper_byte_stream"] = {
  init: function() {
    const validate = (txt: string) => {
      if(!txt) return "";
      // Accept formats: 0x01 02 aa, commas or spaces. Normalize to space separated upper-case hex bytes without 0X prefix (except when user typed 0x)
      const tokens = txt.replace(/[,\n\r\t]+/g,' ').trim().split(/ +/).filter(Boolean).map(t=>{
        t = t.trim();
        if(t.startsWith('0x')||t.startsWith('0X')) t = t.slice(2);
        t = t.replace(/[^0-9A-Fa-f]/g,'');
        if(t.length===0) return null;
        if(t.length===1) t = '0'+t; // pad single nibble
        if(t.length>2) t = t.slice(-2); // keep last byte
        return t.toUpperCase();
      }).filter(Boolean) as string[];
      return tokens.join(' ');
    };
    this.appendDummyInput()
      .appendField("bytes")
      .appendField(new Blockly.FieldTextInput("00 01 02", validate), "BYTES");
    this.setOutput(true, "ByteStream");
    this.setColour(200);
    this.setTooltip("Literal byte stream. Enter hex bytes separated by space or comma (e.g. 0xAA 55 10 FE)");
  }
};

// I2C write multiple bytes starting at memory/register address using furi_hal_i2c_write_mem
Blockly.Blocks["flipper_i2c_write_bytes"] = {
  init: function() {
    this.appendDummyInput()
  .appendField("I2C write bytes bus")
  .appendField(new Blockly.FieldDropdown([["GPIO (PA7 SDA/PA6 SCL)","EXT"],["Internal","PWR"]]), "BUS");
    this.appendValueInput("ADDR").setCheck("Number").appendField("addr (7b)");
    this.appendValueInput("MEM").setCheck("Number").appendField("start reg");
    this.appendValueInput("DATA").setCheck("ByteStream").appendField("data");
    this.appendValueInput("TIMEOUT").setCheck("Number").appendField("timeout ms");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(260);
    this.setTooltip("Writes sequential bytes to device starting at register/memory address (auto acquires bus).");
    const mkHexShadow = (hex:string)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','flipper_hex_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','HEX');f.textContent=hex; s.appendChild(f); return s;};
    const mkNumShadow = (val:number)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','math_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','NUM');f.textContent=String(val);s.appendChild(f);return s;};
    const mkBytesShadow = (bytes:string)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','flipper_byte_stream');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','BYTES');f.textContent=bytes; s.appendChild(f); return s;};
    this.getInput('ADDR')?.connection.setShadowDom(mkHexShadow('0x3C'));
    this.getInput('MEM')?.connection.setShadowDom(mkHexShadow('0x00'));
    this.getInput('DATA')?.connection.setShadowDom(mkBytesShadow('AA 55 01'));
    this.getInput('TIMEOUT')?.connection.setShadowDom(mkNumShadow(50));
  }
};

// I2C read multiple bytes into a new byte stream
Blockly.Blocks["flipper_i2c_read_bytes"] = {
  init: function() {
    this.appendDummyInput()
  .appendField("I2C read bytes bus")
  .appendField(new Blockly.FieldDropdown([["GPIO (PA7 SDA/PA6 SCL)","EXT"],["Internal","PWR"]]), "BUS");
    this.appendValueInput("ADDR").setCheck("Number").appendField("addr (7b)");
    this.appendValueInput("MEM").setCheck("Number").appendField("start reg");
    this.appendValueInput("LEN").setCheck("Number").appendField("length");
    this.appendValueInput("TIMEOUT").setCheck("Number").appendField("timeout ms");
    this.setOutput(true, "ByteStream");
    this.setColour(260);
    this.setTooltip("Reads a burst of bytes starting at register/memory address into a new byte stream.");
    const mkHexShadow = (hex:string)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','flipper_hex_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','HEX');f.textContent=hex; s.appendChild(f); return s;};
    const mkNumShadow = (val:number)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','math_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','NUM');f.textContent=String(val);s.appendChild(f);return s;};
    this.getInput('ADDR')?.connection.setShadowDom(mkHexShadow('0x3C'));
    this.getInput('MEM')?.connection.setShadowDom(mkHexShadow('0x00'));
    this.getInput('LEN')?.connection.setShadowDom(mkNumShadow(8));
    this.getInput('TIMEOUT')?.connection.setShadowDom(mkNumShadow(50));
  }
};

// I2C update bits in an 8-bit register (read-modify-write with mask)
Blockly.Blocks["flipper_i2c_update_bits8"] = {
  init: function() {
    this.appendDummyInput()
  .appendField("I2C update bits bus")
  .appendField(new Blockly.FieldDropdown([["GPIO (PA7 SDA/PA6 SCL)","EXT"],["Internal","PWR"]]), "BUS");
    this.appendValueInput("ADDR").setCheck("Number").appendField("addr (7b)");
    this.appendValueInput("REG").setCheck("Number").appendField("reg");
    this.appendValueInput("MASK").setCheck("Number").appendField("mask");
    this.appendValueInput("VALUE").setCheck("Number").appendField("value");
    this.appendValueInput("TIMEOUT").setCheck("Number").appendField("timeout ms");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(260);
    this.setTooltip("Reads 8-bit register, updates only bits in mask with value (auto computes shift), writes back.");
    const mkHexShadow = (hex:string)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','flipper_hex_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','HEX');f.textContent=hex; s.appendChild(f); return s;};
    const mkNumShadow = (val:number)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','math_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','NUM');f.textContent=String(val);s.appendChild(f);return s;};
    this.getInput('ADDR')?.connection.setShadowDom(mkHexShadow('0x3C'));
    this.getInput('REG')?.connection.setShadowDom(mkHexShadow('0x00'));
    this.getInput('MASK')?.connection.setShadowDom(mkHexShadow('0x0F'));
    this.getInput('VALUE')?.connection.setShadowDom(mkHexShadow('0x05'));
    this.getInput('TIMEOUT')?.connection.setShadowDom(mkNumShadow(50));
  }
};

// Byte stream length
Blockly.Blocks["flipper_byte_stream_length"] = {
  init: function() {
    this.appendValueInput("STREAM").setCheck("ByteStream").appendField("length of bytes");
    this.setOutput(true, "Number");
    this.setColour(200);
    this.setTooltip("Returns number of bytes in a byte stream (compile-time array size).");
  }
};

// Byte stream get index
Blockly.Blocks["flipper_byte_stream_get_byte"] = {
  init: function() {
    this.appendValueInput("STREAM").setCheck("ByteStream").appendField("byte");
    this.appendValueInput("INDEX").setCheck("Number").appendField("at index");
    this.setInputsInline(true);
    this.setOutput(true, "Number");
    this.setColour(200);
    this.setTooltip("Get byte at index (0-based) from byte stream; returns 0 if out of range.");
    const mkNumShadow = (val:number)=>{const s=Blockly.utils.xml.createElement('shadow');s.setAttribute('type','math_number');const f=Blockly.utils.xml.createElement('field');f.setAttribute('name','NUM');f.textContent=String(val);s.appendChild(f);return s;};
    this.getInput('INDEX')?.connection.setShadowDom(mkNumShadow(0));
  }
};
